use libc::{c_double, c_float, c_int, c_void};
use ffi::types::{CvArr, CvBox2D, CvChain, CvChainPtReader, CvConnectedComp, CvContour, CvContourScanner, CvFont, CvHistogram, CvHuMoments, CvLineIterator, CvMat, CvMemStorage, CvMoments, CvPoint, CvPoint2D32f, CvRect, CvScalar, CvSeq, CvSeqBlock, CvSize, CvSlice, CvTermCriteria, IplConvKernel}; 

#[link(name = "opencv_imgproc")]
extern "C" {
  pub fn cvAcc(image: *const CvArr, sum: *const CvArr, mask: *const CvArr); 
  pub fn cvSquareAcc(image: *const CvArr, sqsum: *const CvArr, mask: *const CvArr);
  pub fn cvMultiplyAcc(image1: *const CvArr, image2: *const CvArr, acc: *const CvArr, mask: *const CvArr);
  pub fn cvRunningAvg(image: *const CvArr, acc: *const CvArr, alpha: c_double, mask: *const CvArr);
  pub fn cvCopyMakeBorder(src: *const CvArr, dst: *const CvArr, offset: CvPoint, bordertype: c_int, value: CvScalar);
  pub fn cvSmooth(src: *const CvArr, dst: *const CvArr, smoothtype: c_int, size1: c_int, size2: c_int, sigma1: c_double, sigma2: c_double);
  pub fn cvFilter2D(src: *const CvArr, dst: *const CvArr, kernel: *const CvMat, anchor: CvPoint);
  pub fn cvIntegral(image: *const CvArr, sum: *const CvArr, sqsum: *const CvArr, tilted_sum: *const CvArr);
  pub fn cvPyrDown(src: *const CvArr, dst: *const CvArr, filter: c_int);
  pub fn cvPyrUp(src: *const CvArr, dst: *const CvArr, filter: c_int);
  pub fn cvCreatePyramid(img: *const CvArr, extra_layers: c_int, rate: c_double, layer_sizes: *const CvSize, bufarr: *const CvArr, calc: c_int, filter: c_int) -> *const *const CvMat;
  pub fn cvReleasePyramid(pyramid: *const *const *const CvMat, extra_layers: c_int);
  pub fn cvPyrMeanShiftFiltering(src: *const CvArr, dst: *const CvArr, sp: c_double, sr: c_double, max_level: c_int, termcrit: CvTermCriteria);
  pub fn cvWatershed(image: *const CvArr, markers: *const CvArr);
  pub fn cvSobel(src: *const CvArr, dst: *const CvArr, xorder: c_int, yorder: c_int, aperture_size: c_int);
  pub fn cvLaplace(src: *const CvArr, dst: *const CvArr, aperture_size: c_int);
  pub fn cvCvtColor(src: *const CvArr, dst: *const CvArr, code: c_int);
  pub fn cvResize(src: *const CvArr, dst: *const CvArr, interpolation: c_int);
  pub fn cvWarpAffine(src: *const CvArr, dst: *const CvArr, map_matrix: *const CvMat, flags: c_int, fillval: CvScalar);
  pub fn cvGetAffineTransform(src: *const CvPoint2D32f, dst: *const CvPoint2D32f, map_matrix: *const CvMat) -> *const CvMat;
  pub fn cv2DRotationMatrix(center: CvPoint2D32f, angle: c_double, scale: c_double, map_matrix: *const CvMat) -> *const CvMat;
  pub fn cvWarpPerspective(src: *const CvArr, dst: *const CvArr, map_matrix: *const CvMat, flags: c_int, fillval: CvScalar);
  pub fn cvGetPerspectiveTransform(src: *const CvPoint2D32f, dst: *const CvPoint2D32f, map_matrix: *const CvMat) -> *const CvMat;
  pub fn cvRemap(src: *const CvArr, dst: *const CvArr, mapx: *const CvArr, mapy: *const CvArr, flags: c_int, fillval: CvScalar);
  pub fn cvConvertMaps(mapx: *const CvArr, mapy: *const CvArr, mapxy: *const CvArr, mapalpha: *const CvArr);
  pub fn cvLogPolar(src: *const CvArr, dst: *const CvArr, center: CvPoint2D32f, M: c_double, flags: c_int);
  pub fn cvLinearPolar(src: *const CvArr, dst: *const CvArr, center: CvPoint2D32f, maxRadius: c_double, flags: c_int);
  pub fn cvUndistort2(src: *const CvArr, dst: *const CvArr, camera_matrix: *const CvMat, distortion_coeffs: *const CvMat, new_camera_matrix: *const CvMat);
  pub fn cvInitUndistortMap(camera_matrix: *const CvMat, distortion_coeffs: *const CvMat, mapx: *const CvArr, mapy: *const CvArr);
  pub fn cvInitUndistortRectifyMap(camera_matrix: *const CvMat, dist_coeffs: *const CvMat, R: *const CvMat, new_camera_matrix: *const CvMat, mapx: *const CvArr, mapy: *const CvArr);
  pub fn cvUndistortPoints(src: *const CvMat, dst: *const CvMat, camera_matrix: *const CvMat, dist_coeffs: *const CvMat, R: *const CvMat, P: *const CvMat);
  pub fn cvCreateStructuringElementEx(cols: c_int, rows: c_int, anchor_x: c_int, anchor_y: c_int, shape: c_int, value: *const c_int) -> *const IplConvKernel;
  pub fn cvReleaseStructuringElement(element: *const *const IplConvKernel);
  pub fn cvErode(src: *const CvArr, dst: *const CvArr, element: *const IplConvKernel, iterations: c_int);
  pub fn cvDilate(src: *const CvArr, dst: *const CvArr, element: *const IplConvKernel, iterations: c_int);
  pub fn cvMorphologyEx(src: *const CvArr, dst: *const CvArr, temp: *const CvArr, element: *const IplConvKernel, operation: c_int, iterations: c_int);
  pub fn cvMoments(arr: *const CvArr, moments: *const CvMoments, binary: c_int);
  pub fn cvGetSpatialMoment(moments: *const CvMoments, x_order: c_int, y_order: c_int) -> c_double;
  pub fn cvGetCentralMoment(moments: *const CvMoments, x_order: c_int, y_order: c_int) -> c_double;
  pub fn cvGetNormalizedCentralMoment(moments: *const CvMoments, x_order: c_int, y_order: c_int) -> c_double; 
  pub fn cvGetHuMoments(moments: *const CvMoments, hu_moments: *const CvHuMoments); 
  pub fn cvSampleLine(image: *const CvArr, pt1: CvPoint, pt2: CvPoint, buffer: *const c_void, connectivity: c_int) -> c_int;
  pub fn cvGetRectSubPix(src: *const CvArr, dst: *const CvArr, center: CvPoint2D32f); 
  pub fn cvGetQuadrangleSubPix(src: *const CvArr, dst: *const CvArr, map_matrix: *const CvMat);
  pub fn cvMatchTemplate(image: *const CvArr, temp: *const CvArr, result: *const CvArr, method: c_int);
  pub fn cvCalcEMD2(signature1: *const CvArr, signature2: *const CvArr, distance_type: c_int, distance_func: extern "C" fn(a: *const c_float, b: *const c_float, c: *const c_float, user_param: *const c_void) -> c_float, const_matrix: *const CvArr, flow: *const CvArr, lower_bound: *const c_float, userdata: *const c_void) -> c_float;
  pub fn cvFindContours(image: *const CvArr, storage: CvMemStorage, first_contour: *const *const CvSeq, header_size: c_int, mode: c_int, method: c_int, offset: CvPoint) -> c_int;
  pub fn cvStartFindContours(image: *const CvArr, storage: CvMemStorage, header_size: c_int, mode: c_int, method: c_int, offset: CvPoint) -> CvContourScanner;
  pub fn cvFindNextContour(scanner: CvContourScanner) -> *const CvSeq;
  pub fn cvSubstituteContour(scanner: CvContourScanner, new_contour: *const CvSeq);
  pub fn cvEndFindContours(scanner: *const CvContourScanner) -> *const CvSeq;
  pub fn cvApproxChains(src_seq: *const CvSeq, storage: CvMemStorage, method: c_int, parameter: c_double, minimal_perimeter: c_int, recursive: c_int) -> *const CvSeq;
  pub fn cvStartReadChainPoints(chain: *const CvChain, reader: *const CvChainPtReader);
  pub fn cvReadChainPoint(reader: *const CvChainPtReader) -> CvPoint;
  pub fn cvApproxPoly(src_seq: *const c_void, header_size: c_int, storage: CvMemStorage, method: c_int, eps: c_double, recursive: c_int) -> *const CvSeq;
  pub fn cvArcLength(curve: *const c_void, slice: CvSlice, is_closed: c_int) -> c_double;
  pub fn cvBoundingRect(points: *const CvArr, update: c_int) -> CvRect; 
  pub fn cvContourArea(contour: *const CvArr, slice: CvSlice, oriented: c_int) -> c_double;
  pub fn cvMinAreaRect2(points: *const CvArr, storage: CvMemStorage) -> CvBox2D; 
  pub fn cvMinEnclosingCircle(points: *const CvArr, center: *const CvPoint2D32f, radius: *const c_float) -> c_int;
  pub fn cvMatchShapes(object1: *const c_void, object2: *const c_void, method: c_int, parameter: c_double) -> c_double;
  pub fn cvConvexHull2(input: *const CvArr, hull_storage: *const c_void, orientation: c_int, return_points: c_int) -> *const CvSeq;
  pub fn cvCheckContourConvexity(contour: *const CvArr) -> c_int;
  pub fn cvConvexityDefects(contour: *const CvArr, convexhull: *const CvArr, storage: CvMemStorage) -> *const CvSeq; 
  pub fn cvFitEllipse2(points: *const CvArr) -> CvBox2D;
  pub fn cvMaxRect(rect1: *const CvRect, rect2: *const CvRect) -> CvRect;
  pub fn cvBoxPoints(box_: CvBox2D, pt: *const CvPoint2D32f);
  pub fn cvPointSeqFromMat(seq_kind: c_int, mat: *const CvArr, contour_header: *const CvContour, block: *const CvSeqBlock) -> *const CvSeq;
  pub fn cvPointPolygonTest(contour: *const CvArr, pt: CvPoint2D32f, measure_dist: c_int) -> c_double; 
  pub fn cvCreateHist(dims: c_int, sizes: *const c_int, type_: c_int, ranges: *const *const c_float, uniform: c_int) -> *const CvHistogram;
  pub fn cvSetHistBinRanges(hist: *const CvHistogram, ranges: *const *const c_float, uniform: c_int);
  pub fn cvMakeHistHeaderForArray(dims: c_int, sizes: *const c_int, hist: *const CvHistogram, data: *const c_float, ranges: *const *const c_float, uniform: c_int) -> *const CvHistogram;
  pub fn cvReleaseHist(hist: *const *const CvHistogram);
  pub fn cvClearHist(hist: *const CvHistogram);
  pub fn cvGetMinMaxHistValue(hist: *const CvHistogram, min_value: *const c_float, max_value: *const c_float, min_idx: *const c_int, max_idx: *const c_int);
  pub fn cvNormalizeHist(hist: *const CvHistogram, factor: c_double); 
  pub fn cvThreshHist(hist: *const CvHistogram, threshold: c_double);
  pub fn cvCompareHist(hist1: *const CvHistogram, hist2: *const CvHistogram, method: c_int) -> c_double;
  pub fn cvCopyHist(src: *const CvHistogram, dst: *mut *const CvHistogram);
  pub fn cvCalcBayesianProb(src: *const *const CvHistogram, number: c_int, dst: *const *const CvHistogram);
  pub fn cvCalcArrHist(arr: *const CvArr, hist: *const CvHistogram, accumulate: c_int, mask: *const CvArr);
  pub fn cvCalcArrBackProject(image: *const CvArr, dst: *const CvArr, hist: *const CvHistogram);
  pub fn cvCalcArrBackProjectPatch(image: *const CvArr, dst: *const CvArr, range: CvSize, hist: *const CvHistogram, method: c_int, factor: c_double);
  pub fn cvCalcProbDensity(hist1: *const CvHistogram, hist2: *const CvHistogram, dst_hist: *const CvHistogram, scale: c_double);
  pub fn cvEqualizeHist(src: *const CvArr, dst: *const CvArr); 
  pub fn cvDistTransform(src: *const CvArr, dst: *const CvArr, distance_type: c_int, mask_size: c_int, mask: *const c_float, labels: *const CvArr, label_type: c_int);
  pub fn cvThreshold(src: *const CvArr, dst: *const CvArr, threshold: c_double, max_value: c_double, threshold_type: c_int) -> c_double;
  pub fn cvAdaptiveThreshold(src: *const CvArr, dst: *const CvArr, max_value: c_double, adaptive_method: c_int, threshold_type: c_int, block_size: c_int, param1: c_double);
  pub fn cvFloodFill(image: *const CvArr, seed_point: CvPoint, new_val: CvScalar, lo_diff: CvScalar, up_diff: CvScalar, comp: *const CvConnectedComp, flags: c_int, mask: *const CvArr);
  pub fn cvCanny(image: *const CvArr, edges: *const CvArr, threshold1: c_double, threshold2: c_double, aperture_size: c_int);
  pub fn cvPreCornerDetect(image: *const CvArr, corners: *const CvArr, aperture_size: c_int);
  pub fn cvCornerEigenValsAndVecs(image: *const CvArr, eigenvv: *const CvArr, block_size: c_int, aperture_size: c_int);
  pub fn cvCornerMinEigenVal(image: *const CvArr, eigenval: *const CvArr, block_size: c_int, aperture_size: c_int);
  pub fn cvCornerHarris(image: *const CvArr, harris_response: *const CvArr, block_size: c_int, aperture_size: c_int, k: c_double);
  pub fn cvFindCornerSubPix(image: *const CvArr, corners: *const CvPoint2D32f, count: c_int, win: CvSize, zero_zone: CvSize, criteria: CvTermCriteria);
  pub fn cvGoodFeaturesToTrack(image: *const CvArr, eig_image: *const CvArr, temp_image: *const CvArr, corners: *const CvPoint2D32f, corner_count: *const c_int, quality_level: c_double, min_distance: c_double, mask: *const CvArr, block_size: c_int, use_harris: c_int, k: c_double);
  pub fn cvHoughLines2(image: *const CvArr, line_storage: *const c_void, method: c_int, rho: c_double, theta: c_double, threshold: c_int, param1: c_double, param2: c_double, min_theta: c_double, max_theta: c_double) -> *const CvSeq;
  pub fn cvHoughCircles(image: *const CvArr, circle_storage: *const c_void, method: c_int, dp: c_double, min_dist: c_double, param1: c_double, param2: c_double, min_radius: c_int, max_radius: c_int) -> *const CvSeq;
  pub fn cvFitLine(points: *const CvArr, dist_type: c_int, param: c_double, reps: c_double, aeps: c_double, line: *const c_float);
  pub fn cvLine(img: *const CvArr, pt1: CvPoint, pt2: CvPoint, color: CvScalar, thickness: c_int, line_type: c_int, shift: c_int);
  pub fn cvRectangle(img: *const CvArr, pt1: CvPoint, pt2: CvPoint, color: CvScalar, thickness: c_int, line_type: c_int, shift: c_int);
  pub fn cvRectangleR(img: *const CvArr, r: CvRect, color: CvScalar, thickness: c_int, line_type: c_int, shift: c_int);
  pub fn cvCircle(img: *const CvArr, center: CvPoint, radius: c_int, color: CvScalar, thickness: c_int, line_type: c_int, shift: c_int);
  pub fn cvEllipse(img: *const CvArr, center: CvPoint, axes: CvSize, angle: c_double, start_angle: c_double, end_angle: c_double, color: CvScalar, thickness: c_int, line_type: c_int, shift: c_int);
  pub fn cvFillConvexPoly(img: *const CvArr, pts: *const CvPoint, npts: c_int, color: CvScalar, line_type: c_int, shift: c_int);
  pub fn cvFillPoly(img: *const CvArr, pts: *const *const CvPoint, npts: *const c_int, contour: c_int, color: CvScalar, line_type: c_int, shift: c_int);
  pub fn cvPolyLine(img: *const CvArr, pts: *const *const CvPoint, npts: *const c_int, contour: c_int, is_closed: c_int, color: CvScalar, thickness: c_int, line_type: c_int, shift: c_int);
  pub fn cvClipLine(img_size: CvSize, pt1: *const CvPoint, pt2: *const CvPoint) -> c_int;
  pub fn cvInitLineIterator(image: *const CvArr, pt1: CvPoint, pt2: CvPoint, line_iterator: *const CvLineIterator, connectivity: c_int, left_to_right: c_int) -> c_int;
  pub fn cvInitFont(font: *const CvFont, font_face: c_int, hscale: c_double, vscale: c_double, shear: c_double, thickness: c_int, line_type: c_int);
  pub fn cvPutText(img: *const CvArr, text: *const char, org: CvPoint, font: *const CvFont, color: CvScalar);
  pub fn cvGetTextSize(text_string: *const char, font: *const CvFont, text_size: *const CvSize, baseline: *const c_int);
  pub fn cvColorToScalar(packed_color: c_double, arrtype: c_int) -> CvScalar;
  pub fn cvEllipse2Poly(center: CvPoint, axes: CvSize, angle: c_int, arc_start: c_int, arc_end: c_int, pts: *const CvPoint, delta: c_int) -> c_int;
  pub fn cvDrawContours(img: *const CvArr, contour: *const CvSeq, external_color: CvScalar, hole_color: CvScalar, max_level: c_int, thickness: c_int, line_type: c_int, offset: CvPoint);
}
